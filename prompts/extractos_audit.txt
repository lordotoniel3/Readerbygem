'''\
Eres un experto en validación de datos extraídos de extractos bancarios. Evalúa cada campo del JSON proporcionado asignando un puntaje individual de 0 a 1 según estas reglas y Necesito que me proporciones un score, no necesito un codigo en python, ciñete a los resultados reales que encuentres:

### Reglas de Validación:
1. **Campos Obligatorios** (deben estar presentes y ser válidos):
   - `bankName`: 1 si contiene un nombre de banco válido. 0 si está ausente.
   - `holderName`: 1 si contiene un nombre o razón social válido. 0 si está ausente.
   - `accountNumber`: 1 si contiene un número de cuenta válido. 0 si está ausente.
   - `startDatePeriod`: 1 si es una fecha en formato YYYY-MM-DD. 0.5 si es una fecha pero en otro formato. 0 si no es una fecha o está ausente.
   - `endDatePeriod`: 1 si es una fecha en formato YYYY-MM-DD. 0.5 si es una fecha pero en otro formato. 0 si no es una fecha o está ausente.
   - `actualBalance`: 1 si es un valor numérico. 0.5 si está presente pero no es numérico. 0 si está ausente.

2. **Campos Importantes** (deben ser válidos si están presentes):
   - `currency`: 1 si contiene un código de moneda válido (USD, EUR, COP, etc.) o está ausente. 0 si contiene un valor que no es un código de moneda.
   - `accountType`: 1 si contiene un tipo de cuenta válido (Ahorro, Corriente, etc.) o está ausente. 0 si contiene un valor claramente incorrecto.
   - `clientNumber`: 1 si contiene un número de identificación de cliente o está ausente. 0 si contiene un valor claramente incorrecto.
   - `movements`: 1 si es un array con al menos un elemento o está ausente. 0.5 si es un array vacío. 0 si no es un array.
   - `previousBalance`: 1 si es un valor numérico o está ausente. 0 si está presente pero no es numérico.
   - `totalDeposits`: 1 si es un valor numérico o está ausente. 0 si está presente pero no es numérico.
   - `totalWithdrawals`: 1 si es un valor numérico o está ausente. 0 si está presente pero no es numérico.

3. **Campos Secundarios** (se evalúan si están presentes):
   - Todos los demás campos: 1 si están ausentes o contienen información válida según su categoría. 0.5 si la información parece parcialmente correcta. 0 si contienen información claramente errónea.

### Validaciones específicas:

#### Para los movimientos:
- Cada movimiento debe tener al menos `date`, `description` y `value`.
- El campo `type` debe ser "débito" o "crédito".
- La fecha de cada movimiento debe estar dentro del período del extracto.

#### Para los encargos:
- Si `trusts` está presente:
  - Debe ser una lista de objetos con al menos `trustName` válido.
  - El 'trustName' se refiere al nombre del cliente o negocio en el extracto bancario, tambien puede ser su NIT.
  - Cada encargo puede contener su propia lista de `movements`.
  - Evalúa los movimientos dentro de cada encargo igual que los movimientos globales: deben tener `date`, `description`, `value`, `type`, `subsequentBalance`.
  - La suma de valores en estos movimientos también debe guardar coherencia si hay valores agregados como `trustValue`.

- Si `trusts` está vacío pero debería haber encargos, penaliza.
#### Para valores monetarios:
- Deben ser valores numéricos sin símbolos de moneda ni separadores de miles.
- El `actualBalance` debe ser aproximadamente igual a `previousBalance` + `totalDeposits` - `totalWithdrawals`.

#### Para fechas:
- Deben estar en formato YYYY-MM-DD.
- La `startDatePeriod` debe ser anterior a la `endDatePeriod`.
- La `statementIssueDate` no debe ser anterior a la `endDatePeriod`.

### Validaciones de coherencia:
- El total de movimientos de crédito debe aproximarse al valor de `totalDeposits`.
- El total de movimientos de débito debe aproximarse al valor de `totalWithdrawals`.
- Si hay movimientos, verificar que el último saldo posterior en los movimientos sea similar al `actualBalance`.

### Instrucciones Adicionales:
- Ignora cualquier campo que no esté en la estructura definida.
- Sé estricto con los formatos de fechas y valores numéricos.
- Verifica que cada dato corresponda a la categoría definida por el nombre. Penaliza errores obvios.
- Todos los scores deben ser numéricos de punto flotante y no strings u otro formato.

### Salida Requerida:
Devuelve únicamente un JSON con la siguiente estructura:
```json
{{
  "scores": {{
    "bankName": <valor entre 0 y 1>,
    "bankAddress": <valor entre 0 y 1>,
    "bankTel": <valor entre 0 y 1>,
    "holderName": <valor entre 0 y 1>,
    "clientNumber": <valor entre 0 y 1>,
    "holderAddress": <valor entre 0 y 1>,
    "accountType": <valor entre 0 y 1>,
    "accountNumber": <valor entre 0 y 1>,
    "currency": <valor entre 0 y 1>,
    "startDatePeriod": <valor entre 0 y 1>,
    "endDatePeriod": <valor entre 0 y 1>,
    "previousBalance": <valor entre 0 y 1>,
    "actualBalance": <valor entre 0 y 1>,
    "totalDeposits": <valor entre 0 y 1>,
    "totalWithdrawals": <valor entre 0 y 1>,
    "totalCommissions": <valor entre 0 y 1>,
    "movements": <valor entre 0 y 1>,
    "interestRate": <valor entre 0 y 1>,
    "interestEarned": <valor entre 0 y 1>,
    "withholding": <valor entre 0 y 1>,
    "nextCutOffDate": <valor entre 0 y 1>,
    "statementIssueDate": <valor entre 0 y 1>,
    "statementNumber": <valor entre 0 y 1>,
    "trusts": <valor entre 0 y 1>

  }},
  "explicacion": "Detalle de los errores o inconsistencias encontrados en cada campo (dejar vacío si todo es correcto)."
}}
```

Donde:
- `scores`: Puntajes individuales para cada campo basado en las métricas expuestas.
- `explicacion`: Breve informe de los errores encontrados. Si no hay errores significativos, deja esta sección vacía.

Información a validar:
{df_data}
'''